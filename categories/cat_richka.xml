<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RICHKA Developer Blog (Posts about RICHKA)</title><link>https://cocktailmake.github.io/</link><description></description><atom:link href="https://cocktailmake.github.io/categories/cat_richka.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2021 &lt;a href="mailto:"&gt;RICHKA&lt;/a&gt; </copyright><lastBuildDate>Tue, 05 Jan 2021 11:21:54 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>License check by scancode-toolkit</title><link>https://cocktailmake.github.io/posts/license-check-by-scancode-toolkit/</link><dc:creator>Bui Dinh Cuong</dc:creator><description>&lt;div id="outline-container-orgbc006f8" class="outline-2"&gt;
&lt;h2 id="orgbc006f8"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbc006f8"&gt;
&lt;p&gt;
In this post, we introduce a method of automating the process of Python codes license scanning by using:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;Scancode-toolkit&lt;/code&gt;: To perform code license scanning.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jenkins&lt;/code&gt;: Run this test automatically based on changes of code on target branch.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org58b0a6c" class="outline-2"&gt;
&lt;h2 id="org58b0a6c"&gt;Steps&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org58b0a6c"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0e11ace" class="outline-3"&gt;
&lt;h3 id="org0e11ace"&gt;Prepare environment&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0e11ace"&gt;
&lt;p&gt;
Before we start, make sure the system satisfy below mentioned requirements:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Python3.6 installed&lt;/li&gt;
&lt;li&gt;Git &amp;amp; pip configured&lt;/li&gt;
&lt;li&gt;Jenkins servers installed &amp;amp; configured&lt;/li&gt;
&lt;li&gt;Identify git branch for code scanning&lt;/li&gt;
&lt;li&gt;Install &lt;code&gt;Scancode-toolkit&lt;/code&gt; tool (See guide from &lt;a href="https://scancode-toolkit.readthedocs.io/en/latest/getting-started/newcomer.html#installing-scancode"&gt;https://scancode-toolkit.readthedocs.io/en/latest/getting-started/newcomer.html#installing-scancode&lt;/a&gt;). Because our project is using Python3.8 which has not been supported by Scancode-toolkit (&lt;a href="https://scancode-toolkit.readthedocs.io/en/latest/getting-started/install.html"&gt;https://scancode-toolkit.readthedocs.io/en/latest/getting-started/install.html&lt;/a&gt;) so we have to use Miniconda (&lt;a href="https://docs.conda.io/en/latest/miniconda.html"&gt;https://docs.conda.io/en/latest/miniconda.html&lt;/a&gt;) to create Python3.6 environment, build binary version and use it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6b914dc" class="outline-3"&gt;
&lt;h3 id="org6b914dc"&gt;Create Jenkins job&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6b914dc"&gt;
&lt;p&gt;
From home page of Jenkins:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Click "New Item"&lt;/li&gt;
&lt;li&gt;Enter a name of the new job, for example: "Check-License-Scan-Code"&lt;/li&gt;
&lt;li&gt;Choose "Freestyle project" then click "OK" to go to next steps&lt;/li&gt;
&lt;/ul&gt;


&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-1.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1e571d9" class="outline-3"&gt;
&lt;h3 id="org1e571d9"&gt;Configure Jenkins job&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1e571d9"&gt;
&lt;p&gt;
After clicking "OK" button in the previous step, we will see a GUI that contains steps to configure Jenkins job. We will go over step by step.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "General" step, we should add a description for this Jenkins job and configure log rotation to prevent too many logs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "Source Code Management" step, you have to do following actions:

&lt;ul class="org-ul"&gt;
&lt;li&gt;Enter your repository (From GitHub, GitLab, Bitbucket, Backlog, .etc)&lt;/li&gt;
&lt;li&gt;Add credentials that can pull codes from a remote branch and select it.&lt;/li&gt;
&lt;li&gt;Provide a branch that you want to check (In this example, I want to scan stage branch).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Besides, there are many other additional behaviors that you can add more. For example, your project has submodules and need to scan them as well, you can add "Advanced sub-modules behaviors" and do configure. Our project has sub-modules so I added this behavior and do recursively.
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-3.png" alt="nil"&gt;
&lt;/p&gt;


&lt;ul class="org-ul"&gt;
&lt;li&gt;In "Build Triggers" step, there are many options that you can run this job but I will choose "Poll SCM". This will allow me to configure to run this job like a crontab in Linux system. For example, I will run this job once an hour (Using Poll SCM then the job will run if there is a new change of code only). In "Build Environment" step, you can choose some options for building like "Delete workspace before build starts", Add timestamps to the Console Output", .etc. It's up to you. My suggestion is that you should add "Add timestamps to the Console Output" then you can know the build time when checking the output log again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-4.png" alt="nil"&gt;
&lt;/p&gt;


&lt;ul class="org-ul"&gt;
&lt;li&gt;"Build" step: Because I installed bandit on Jenkins server, so I will choose "Execute shell" for this step. I will use bandit to scan all source folder from git repository and try to find if there is any "High Severity" item. If there is any item, I will use "exit 1" to mark that this build is failed. Otherwise, the build is success. Then we can use "Post-build Actions" to define response actions with each type of status.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Here is content of script that I will run:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;target_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./source
&lt;span class="nv"&gt;result_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;license-check-result
mkdir -p &lt;span class="nv"&gt;$result_dir&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/lib64
/home/jenkins/toolkits/scancode-toolkit-3.1.1/scancode --license --copyright --summary-with-details --processes &lt;span class="m"&gt;2&lt;/span&gt; --json-pp &lt;span class="nv"&gt;$result_dir&lt;/span&gt;/result.json --html &lt;span class="nv"&gt;$result_dir&lt;/span&gt;/result.html &lt;span class="nv"&gt;$target_dir&lt;/span&gt;
&lt;span class="nv"&gt;parsed_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$result_dir&lt;/span&gt;&lt;span class="s2"&gt;/result1.json"&lt;/span&gt;
&lt;span class="nv"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;cat &lt;span class="nv"&gt;$result_dir&lt;/span&gt;/result.json&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$JSON&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tr &lt;span class="s1"&gt;'\r\n'&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;'.files[].licenses[].matched_rule.licenses | join(",")'&lt;/span&gt; &amp;gt; &lt;span class="nv"&gt;$parsed_file&lt;/span&gt;

&lt;span class="nv"&gt;gpl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"gpl"&lt;/span&gt;
&lt;span class="nv"&gt;invalid_license_count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; line
&lt;span class="k"&gt;do&lt;/span&gt;
	&lt;span class="nv"&gt;licenses&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s2"&gt;"s/\"//g"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tr &lt;span class="s2"&gt;","&lt;/span&gt; &lt;span class="s2"&gt;"\n"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
	&lt;span class="nv"&gt;sub_license_valid_count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
	&lt;span class="k"&gt;for&lt;/span&gt; license in &lt;span class="nv"&gt;$licenses&lt;/span&gt;
	&lt;span class="k"&gt;do&lt;/span&gt;
	    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$license&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt;  *&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$gpl&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;* &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
		&lt;span class="nv"&gt;sub_license_valid_count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;sub_license_valid_count+1&lt;span class="k"&gt;))&lt;/span&gt;
		&lt;span class="nb"&gt;break&lt;/span&gt;
	    &lt;span class="k"&gt;fi&lt;/span&gt;
	&lt;span class="k"&gt;done&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$sub_license_valid_count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
		&lt;span class="nv"&gt;invalid_license_count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$((&lt;/span&gt;invalid_license_count+1&lt;span class="k"&gt;))&lt;/span&gt;
	&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt; &amp;lt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$parsed_file&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$invalid_license_count&lt;/span&gt; -gt &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-5.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
"Post-build Actions" will support us to define actions that we want to do when the build is failed. There are many actions that we can choose. Following my opinion, I mostly use "E-mail Notification" then I will know when this job is failed to check and make it works as it should be.
All's done! Now you can click "Save" and then click "Build Now" to build this job. If it's failed, you can go to the failed build and check "Console Output" to find out the reason and fix this. Otherwise, you can sleep well because there is no high severity issues on your code.
&lt;/p&gt;

&lt;p&gt;
Here is an example of an output that you can see on "Console Output" on a build item (You can see it when the job is running, it will be loaded in real-time).
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/license-check-by-scancode-toolkit/step-6.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Thanks for your reading to the end of this post!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>license</category><guid>https://cocktailmake.github.io/posts/license-check-by-scancode-toolkit/</guid><pubDate>Mon, 04 Jan 2021 00:30:52 GMT</pubDate></item><item><title>Find Security Issues With Bandit</title><link>https://cocktailmake.github.io/posts/find-security-issues-with-bandit/</link><dc:creator>Bui Dinh Cuong</dc:creator><description>&lt;figure&gt;&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/jenkins+bandit.png"&gt;&lt;/figure&gt; &lt;div id="outline-container-org5d81642" class="outline-2"&gt;
&lt;h2 id="org5d81642"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5d81642"&gt;
&lt;p&gt;
In this post, we introduce a method of automating the process of code review of Python codes by using:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;Bandit&lt;/code&gt;: To perform code review &amp;amp; find security issues of Python codes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jenkins&lt;/code&gt;: Run this test automatically based on changes of code on target branch.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc76cbd3" class="outline-2"&gt;
&lt;h2 id="orgc76cbd3"&gt;Steps&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc76cbd3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6c88c67" class="outline-3"&gt;
&lt;h3 id="org6c88c67"&gt;Prepare environment&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6c88c67"&gt;
&lt;p&gt;
Before we start, make sure the system satisfy below mentioned requirements:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Python2.7/Python3 installed&lt;/li&gt;
&lt;li&gt;Git &amp;amp; pip configured&lt;/li&gt;
&lt;li&gt;Jenkins servers installed &amp;amp; configured&lt;/li&gt;
&lt;li&gt;Identify git branch for code scanning&lt;/li&gt;
&lt;li&gt;Install &lt;code&gt;bandit&lt;/code&gt; tool (See guide from &lt;a href="https://github.com/PyCQA/bandit"&gt;https://github.com/PyCQA/bandit&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6ff57b9" class="outline-3"&gt;
&lt;h3 id="org6ff57b9"&gt;Create Jenkins job&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6ff57b9"&gt;
&lt;p&gt;
From home page of Jenkins:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Click "New Item"&lt;/li&gt;
&lt;li&gt;Enter a name of the new job, for example: "Security-Issues-Scanner"&lt;/li&gt;
&lt;li&gt;Choose "Freestyle project" then click "OK" to go to next steps&lt;/li&gt;
&lt;/ul&gt;


&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/create-new-jenkins-item.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2a32c7a" class="outline-3"&gt;
&lt;h3 id="org2a32c7a"&gt;Configure Jenkins job&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2a32c7a"&gt;
&lt;p&gt;
After clicking "OK" button in the previous step, we will see a GUI that contains steps to configure Jenkins job. We will go over step by step.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "General" step, we should add a description for this Jenkins job and configure log rotation to prevent too many logs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/general-information.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "Source Code Management" step, you have to do following actions:

&lt;ul class="org-ul"&gt;
&lt;li&gt;Enter your repository (From GitHub, GitLab, Bitbucket, Backlog, .etc)&lt;/li&gt;
&lt;li&gt;Add credentials that can pull codes from a remote branch and select it.&lt;/li&gt;
&lt;li&gt;Provide a branch that you want to check (In this example, I want to scan stage branch).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/source-code-management.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
There are many other additional behaviors that you can add more. For example, your project has submodules and need to scan them as well, you can add "Advanced sub-modules behaviors" and do configure.
Here is list most behaviors that you can add:
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/source-code-additional-behaviors.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "Build Triggers" step, there are many options that you can run this job but I will choose "Poll SCM". This will allow me to configure to run this job like a crontab in Linux system. For example, I will run this job once an hour (Using Poll SCM then the job will run if there is a new change of code only).&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/build-trigger-poll-scm.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;In "Build Environment" step, you can choose some options for building like "Delete workspace before build starts", Add timestamps to the Console Output", .etc. It's up to you. My suggestion is that you should add "Add timestamps to the Console Output" then you can know the build time when checking the output log again.&lt;/li&gt;

&lt;li&gt;"Build" step: Because I installed bandit on Jenkins server, so I will choose "Execute shell" for this step. I will use bandit to scan all source folder from git repository and try to find if there is any "High Severity" item. If there is any item, I will use "exit 1" to mark that this build is failed. Otherwise, the build is success. Then we can use "Post-build Actions" to define response actions with each type of status.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Here is content of script that I will run:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bandit -r ./source &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tee ./out.log
&lt;span class="nv"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;grep &lt;span class="s2"&gt;"Severity: High"&lt;/span&gt; ./out.log &lt;span class="p"&gt;|&lt;/span&gt; wc -l&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$num&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/build-script.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;"Post-build Actions" will support us to define actions that we want to do when the build is failed. There are many actions that we can choose:&lt;/li&gt;
&lt;/ul&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/post-build-actions.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
With my opinion, I mostly use "E-mail Notification" then I will know when this job is failed to check and make it works as it should be.
All's done! Now you can click "Save" and then click "Build Now" to build this job. If it's failed, you can go to the failed build and check "Console Output" to find out the reason and fix this. Otherwise, you can sleep well because there is no high severity issues on your code.
&lt;/p&gt;

&lt;p&gt;
Here is an example of an output that you can see on "Console Output" on a build item (You can see it when the job is running, it will be loaded in real-time).
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/find-security-issues-with-bandit/example-of-output-console.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Thanks for your reading to the end of this post! I also want to thank "Digital Varys" with meaningful preview image!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>bandit</category><category>security</category><guid>https://cocktailmake.github.io/posts/find-security-issues-with-bandit/</guid><pubDate>Sat, 31 Oct 2020 08:43:55 GMT</pubDate></item><item><title>RICHKA Web API</title><link>https://cocktailmake.github.io/posts/richka-web-api/</link><dc:creator>Hitoshi Uchida</dc:creator><description>&lt;div id="outline-container-org430f534" class="outline-2"&gt;
&lt;h2 id="org430f534"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org430f534"&gt;
&lt;p&gt;
RICHKA provides two interfaces with GUI and Web API to enables users
to easily create video data with setting images, videos and texts and
generating videos. In this post, we describe the Web API whose
architecture conforms to the general REST architecture. It enables
users to integrate the primary features of RICHKA into their systems
such as smartphone application to generate videos with using the photo
album.
&lt;/p&gt;

&lt;p&gt;
The main functions of Web API are below, and they are built with &lt;a href="https://www.django-rest-framework.org/"&gt;Django REST Framework&lt;/a&gt;.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Authenticate API clients and publish API tokens&lt;/li&gt;
&lt;li&gt;Get list of projects/videos&lt;/li&gt;
&lt;li&gt;Create projects / videos&lt;/li&gt;
&lt;li&gt;Set images / videos / texts to scenes of videos&lt;/li&gt;
&lt;li&gt;Generate video files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The basic sequence diagram to generate videos is below.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/richka-web-api/sequence.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org44d42ac" class="outline-2"&gt;
&lt;h2 id="org44d42ac"&gt;Client Authentication&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org44d42ac"&gt;
&lt;p&gt;
To call Web API, API clients need to set tokens &lt;code&gt;TOKEN_AUTH&lt;/code&gt; in every
request. The tokens are published with sending HTTP POST to
&lt;code&gt;/api/v1/api-token-auth/&lt;/code&gt; with the account information. API clients
should store the tokens into their database to suppress this API call
every time.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X POST https://API_HOST/api/v1/accounts/login/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -d &lt;span class="s1"&gt;'{&lt;/span&gt;
&lt;span class="s1"&gt;       "email": "USER_EMAIL",&lt;/span&gt;
&lt;span class="s1"&gt;       "password": "USER_PASSWORD"&lt;/span&gt;
&lt;span class="s1"&gt;     }'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0dc33eb" class="outline-2"&gt;
&lt;h2 id="org0dc33eb"&gt;Create New Project&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0dc33eb"&gt;
&lt;p&gt;
A new project directory is created with sending HTTP POST to
&lt;code&gt;/api/v1/projects/&lt;/code&gt; as below.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X POST https://API_HOST/api/v1/projects/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -d &lt;span class="s1"&gt;'{&lt;/span&gt;
&lt;span class="s1"&gt;       "name": "New Project",&lt;/span&gt;
&lt;span class="s1"&gt;       "is_shared": true&lt;/span&gt;
&lt;span class="s1"&gt;     }'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The ID of the created project &lt;code&gt;PROJECT_ID&lt;/code&gt; is returned to the clients.
The detail information of the project can be obtained with sending
HTTP GET to &lt;code&gt;/v1/projects/PROJECT_ID/&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdab025b" class="outline-2"&gt;
&lt;h2 id="orgdab025b"&gt;Get a list of video templates&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdab025b"&gt;
&lt;p&gt;
API clients can get a list of available template IDs TEMPLATE_ID with
sending HTTP GET to &lt;code&gt;/api/v1/template_groups/&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X GET https://API_HOST/api/v1/template_groups/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0c0b694" class="outline-2"&gt;
&lt;h2 id="org0c0b694"&gt;Create New Video Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0c0b694"&gt;
&lt;p&gt;
A new video data is created with sending HTTP POST to
&lt;code&gt;/api/v1/videos/&lt;/code&gt; with specifying the created project id &lt;code&gt;PROJECT_ID&lt;/code&gt;
and the selected video template &lt;code&gt;TEMPLATE_ID&lt;/code&gt;.  The ID of the created
video data &lt;code&gt;VIDEO_ID&lt;/code&gt; is returned to the clients.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X POST https://API_HOST/api/v1/videos/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -d &lt;span class="s1"&gt;'{&lt;/span&gt;
&lt;span class="s1"&gt;       "name": "your video title",&lt;/span&gt;
&lt;span class="s1"&gt;       "project_id": "PROJECT_ID",&lt;/span&gt;
&lt;span class="s1"&gt;       "template_id": TEMPLATE_ID&lt;/span&gt;
&lt;span class="s1"&gt;     }'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9266698" class="outline-2"&gt;
&lt;h2 id="org9266698"&gt;Set Images / Videos / Texts into Scenes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9266698"&gt;
&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/richka-web-api/api-scene-setting.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
For 1st step, API clients need to upload the image/video files to be
available in the video data with &lt;code&gt;VIDEO_ID&lt;/code&gt;.
Then &lt;code&gt;IMAGE_NAME_1&lt;/code&gt; and &lt;code&gt;IMAGE_NAME_2&lt;/code&gt; are returned to the clients.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;curl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;POST&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;API_HOST&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;videos&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VIDEO_ID&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; \
     &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; \
     &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="s1"&gt;'content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW'&lt;/span&gt; \
     &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="s1"&gt;'files[]=@/path/to/image/1.png'&lt;/span&gt; \
     &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="s1"&gt;'files[]=@/path/to/image/2.jpeg'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
After uploading the file contents, API clients can set the images into
scenes of the video data with using the identifiers &lt;code&gt;IMAGE_NAME_1&lt;/code&gt; and
&lt;code&gt;IMAGE_NAME_2&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;curl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;PUT&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;API_HOST&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;videos&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VIDEO_ID&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; \
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; \
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt; \
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="s1"&gt;'{&lt;/span&gt;
    &lt;span class="s2"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"New video'&lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="s2"&gt;'s name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;"bgm_file"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;BGM_ID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;"memo"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"New Memo"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;"slides"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
	&lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="s2"&gt;"index"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	    &lt;span class="s2"&gt;"text"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"ãã­ã¹ã"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	    &lt;span class="s2"&gt;"image_name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"IMAGE_NAME_1"&lt;/span&gt;
	&lt;span class="p"&gt;},&lt;/span&gt;
	&lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="s2"&gt;"index"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	    &lt;span class="s2"&gt;"text"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"ãã­ã¹ã"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	    &lt;span class="s2"&gt;"image_name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"IMAGE_NAME_2"&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5b18dc6" class="outline-2"&gt;
&lt;h2 id="org5b18dc6"&gt;Generate Videos&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5b18dc6"&gt;
&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/richka-web-api/api-video-generation.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
After the scenes have been set up, API clients can request to start
the video generation with video servers.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X POST https://API_HOST/api/v1/videos/VIDEO_ID/generate/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When the video generation has been done, a Webhook URL registered in
the account setting page beforehand will be called back with sending
&lt;code&gt;VIDEO_ID&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
  video_id: VIDEO_ID,
  user_id: xxxxx,
  time: &lt;span class="m"&gt;2020&lt;/span&gt;-01-01 &lt;span class="m"&gt;01&lt;/span&gt;:02:03,
  webhook_id: &lt;span class="m"&gt;1234&lt;/span&gt;,
  type: webhook
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org899fbac" class="outline-2"&gt;
&lt;h2 id="org899fbac"&gt;Download Video Contents&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org899fbac"&gt;
&lt;p&gt;
API clients can get the downloadable S3 URLs with sending HTTP GET
with &lt;code&gt;/api/v1/videos/VIDEO_ID/&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl -X GET https://API_HOST/api/v1/videos/VIDEO_ID/ &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Authorization: Token TOKEN_AUTH'&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
     -H &lt;span class="s1"&gt;'Content-Type: application/json'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Web API</category><guid>https://cocktailmake.github.io/posts/richka-web-api/</guid><pubDate>Fri, 16 Oct 2020 06:38:24 GMT</pubDate></item><item><title>The prototype of Morphing</title><link>https://cocktailmake.github.io/posts/the-prototype-of-morphing/</link><dc:creator>Bui Dinh Cuong</dc:creator><description>&lt;div id="outline-container-orgbef4249" class="outline-2"&gt;
&lt;h2 id="orgbef4249"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbef4249"&gt;
&lt;p&gt;
In this post, we introduce HyperMorph on HTML5 that allow us to create motions of objects and then export these motions into video files.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc592ea6" class="outline-2"&gt;
&lt;h2 id="orgc592ea6"&gt;Definitions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc592ea6"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2ff595b" class="outline-3"&gt;
&lt;h3 id="org2ff595b"&gt;Morphing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2ff595b"&gt;
&lt;p&gt;
Morphing is a special effect in motion pictures and animations that change (or morphs) one image or shape into another through a seamless transition. Traditionally such a depiction would be achieved through dissolving techniques on film. Since the early 1990s, this has been replaced by computer software to create more realistic transitions. A similar method is applied to audio recordings in similar fashion, for example, by changing voices or vocal lines.
&lt;/p&gt;

&lt;p&gt;
Source: &lt;a href="https://en.wikipedia.org/wiki/Morphing"&gt;https://en.wikipedia.org/wiki/Morphing&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6ffa1b2" class="outline-3"&gt;
&lt;h3 id="org6ffa1b2"&gt;HyperMorph&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6ffa1b2"&gt;
&lt;p&gt;
There are many terminologies on HyperMorph that you can check on &lt;a href="https://blog.altair.co.kr/wp-content/uploads/2011/03/hypermorph.pdf"&gt;https://blog.altair.co.kr/wp-content/uploads/2011/03/hypermorph.pdf&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Within this post, we just define a simple definition about HyperMorph on video generation. It is a set of points from a 1st image and a corresponding set of points from a 2nd image.
A special effect will change two sets together and makes the 1st image become the 2nd image and vice versa.
When we define enough of points, it will be able to create very smooth video.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org59d60c7" class="outline-2"&gt;
&lt;h2 id="org59d60c7"&gt;How to create HyperMorph from two images with HTML &amp;amp; JavaScript&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org59d60c7"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Define the set of points on the 1st image and a corresponding set of points from 2nd image.&lt;/li&gt;
&lt;li&gt;Using HTML5 canvas to draw a shrink image based on moving points between two sets and merge two images.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/the-prototype-of-morphing/dog_and_cat.png" alt="nil"&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;With each moving step, capture the image on the canvas and add it as a frame of a video.&lt;/li&gt;
&lt;li&gt;When capture enough frames of a video, we can export these frames into a video file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
And here is the output video (I converted to GIF file to display here easily):
&lt;/p&gt;

&lt;p align="center"&gt;
&lt;img src="https://cocktailmake.github.io/images/the-prototype-of-morphing/video.gif" alt="nil"&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://cocktailmake.github.io/posts/the-prototype-of-morphing/</guid><pubDate>Fri, 14 Aug 2020 06:00:00 GMT</pubDate></item><item><title>Realtime Display of Video Generation Progress</title><link>https://cocktailmake.github.io/posts/progress-display-of-video-generation/</link><dc:creator>Hitoshi Uchida</dc:creator><description>&lt;div id="outline-container-org4d7a98c" class="outline-2"&gt;
&lt;h2 id="org4d7a98c"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4d7a98c"&gt;
&lt;p&gt;
The video generation in RICHKA is to serialize high quality videos on
video servers with using video templates designed by export
designers. The processing is heavy load and takes several minutes,
therefore RICHKA has a dedicated GUI feature to show the progress
ratio in realtime so that users can check the remained waiting
time. During the processing, video servers monitor the detail
progresses and transmit to web servers to feedback to users on GUI.
&lt;/p&gt;

&lt;p&gt;
RICHKA uses HTTP streaming for the realtime transmitting of the
progress ratio among servers. This feature is to continue send
application data little by little formatted with HTTP chunked
encoding. During sending them, the TCP connection is kept to open. The
HTTP streaming is available on general high-level web server
frameworks as well and we are ready to apply to product services
without taking care the underlying protocol format by
ourselves. However, we need to understand the restriction that the
HTTP connection is per URL. The restriction is simple, but we
sometimes encounter difficulties on practical service products.
&lt;/p&gt;

&lt;p&gt;
In the case of RICHKA, when users click a button to generate videos on
editing pages, it redirects users to top page to see the progress
ration on the video list so that users can edit other videos during
generation videos. Then, the TCP connection between web browsers and
web servers are disconnected in redirecting because of the restriction
and the progress reporting from video servers don't reach to web
browsers. To enable to show the realtime progress after HTTP
redirecting, RICHKA has a dedicated server side processing and this
post explains how RICHKA does. There are several alternatives to
realize this feature, but RICHKA doesn't depend on additional external
services and the internal architecture is also simple and straight
forward. I think this architecture could be applied to general use
cases and I hope this post provides some hints to readers of this
blog.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbf1d2fb" class="outline-2"&gt;
&lt;h2 id="orgbf1d2fb"&gt;Technical Restriction of HTTP streaming&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbf1d2fb"&gt;
&lt;p width="1500px"&gt;
&lt;img src="https://cocktailmake.github.io/images/progress-display-of-video-generation/restriction.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The figure above represents the detail procedure how the progress reporting
with the HTTP streaming is blocked. The bottom is the GUI of RICHKA
and the left side is the editing page to input user data and the right
side is the top page listing up users' videos. The blue arrow
represents the HTTP redirect to navigate users to a top page and it is
triggered when users click the button of video generation on the
editing pages. In the timing, the HTTP streaming response from web
servers are disconnected and the top page can't get the further
progress ratio. The detail procedure in the figure is below.
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;On edit pages, when users click a button to generate videos, it sends a HTTP request with XMLHttpRequest to one of web serves via load balancer. Then the browser is redirect to the top page listing video data.&lt;/li&gt;
&lt;li&gt;The Web server delegates the video generation to one of video servers with sending a HTTP request again. The video server loads a video template and start to generate a video&lt;/li&gt;
&lt;li&gt;During generating, the video server sends the progress ratio with HTTP chunked encoding whose application data is JSON format to the web server.&lt;/li&gt;
&lt;li&gt;The web server transfers the progress ratio received from the video server, but the TCP connection with the web browser has been already disconnected and the data can't reach it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
For a reference, the chunked transfer encoding is like this. In
general, CGI scripts response with using it. Content-Length header is
not used because the expected data size is not known beforehand. A
chunked data starts with the payload size and it ends with a line
break CR LF. In the final chunk, we need to send an empty chunked data
to notify it is last one to the receiver. In RICHKA, the application
data is the progress ratio formatted with JSON.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

5\r\n
Hello\r\n
6\r\n
RICHKA\r\n
0\r\n
\r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgd55d948" class="outline-2"&gt;
&lt;h2 id="orgd55d948"&gt;Realtime Display of Video Generation Progress after HTTP Redirect&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd55d948"&gt;
&lt;p width="1500px"&gt;
&lt;img src="https://cocktailmake.github.io/images/progress-display-of-video-generation/solution.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
To resolve this restriction deriving from the HTTP connection per URL,
RICHKA realizes the realtime feedback of progress ratio with the
architecture above for the specific case of redirecting. The detail procedure is below.
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;ditto with the prior section&lt;/li&gt;
&lt;li&gt;The web server forks a dedicated process to communicate with the video server. It sends a HTTP request and delegates the video generation. In this timing, the TCP connection is disconnected with the web browser because of the redirection.&lt;/li&gt;
&lt;li&gt;The forked process is still alive and it continues to receive the progress ratio from video serves with HTTP chunked encoding.&lt;/li&gt;
&lt;li&gt;Every when the forked process receives the progress ratio, it saves into database as the progress data for the video data.&lt;/li&gt;
&lt;li&gt;After redirecting, the top page periodically sends HTTP GET request to the web server and show the progress data on GUI.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
At the last step, there is alternative method with WebSocket protocol,
but RICHKA doesn't use because general users access from their company
offices and it is general their networks apply HTTP
proxies. Unfortunately, some of HTTP proxies block WebSocket
connection to enhance the web security. Therefore, RICHKA
intentionally applies the traditional method to make more stable.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Infra</category><category>RICHKA</category><guid>https://cocktailmake.github.io/posts/progress-display-of-video-generation/</guid><pubDate>Sat, 16 May 2020 09:07:20 GMT</pubDate></item><item><title>Big picture of RICHKA</title><link>https://cocktailmake.github.io/posts/big-picture-of-richka/</link><dc:creator>Hitoshi Uchida</dc:creator><description>&lt;div id="outline-container-org35a09f3" class="outline-2"&gt;
&lt;h2 id="org35a09f3"&gt;Abstract&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35a09f3"&gt;
&lt;p&gt;
This is the first post from our engineer team.
&lt;/p&gt;

&lt;p&gt;
We periodically share technological topics such as new integrated
features into products and new technologies we are interested in and
prototype implementations to evaluate the feasibility whether they are
worth developing as actual business service.
&lt;/p&gt;

&lt;p&gt;
In this post, we introduce a web application RICHKA which enables
users to easily create high quality videos on web browsers,
especially, the development environment and the server infra
structures and the processing sequence of the primary function to
generate high quality videos with using image/videos users upload. The
architecture and internal processing are generally complicated than
general services such as EC and blog and chat system because the size
of video files are huge and we need to carefully take care the load of
servers such as delegating heavy processing to other dedicated video
servers and applying delaying processing to postpone heavy processing
later. And the load of file storage is also high and we need to take
care the timing to load files from network storage. On GUI, we don't
initially load video contents because it increases the load of web
servers and delay the response and influences to UX. Instead, we load
thumbnails of any videos on GUI and load video contents only when they
are played on video player.
&lt;/p&gt;

&lt;p&gt;
RICHKA has some dedicated video engines to generate high quality
videos with using well designed video templates created by expert
designers. To make the representation of videos richer, video servers
enable to change not only input texts and image/video material files
users upload, but also font family and color scheme and BGM in
realtime during generating videos. The load of video generation
processing is very heavy and we apply lots of optimization to reduce
the generation time with keeping the high quality. Therefore video
services demand higher development skills of web applications.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org2840d2c" class="outline-2"&gt;
&lt;h2 id="org2840d2c"&gt;RICHKA Development Environment&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2840d2c"&gt;
&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/big-picture-of-richka/technologies-building-richka.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The engineer team is basically remote and more than 90% live in
foreign countries. We hire only high skill experts who have strong
skills of web technologies and web application development. We will
describe our team more on another post later.
&lt;/p&gt;

&lt;p&gt;
We always apply new emerged technologies into products to enhance the
features and reduce development cost. It is free for our engineers to
propose them to see the feasibility and the side effect. The speed of
try and error is faster than general teams because our team is
completely flat and every member has the privilege to propose new
ideas among members. If clear and reasonable purposes are explained to
the team, they are basically accepted.
&lt;/p&gt;

&lt;p&gt;
Regarding server side, it is based on Python and Django and we use
additional 42 Python packages such as Django extensions and
image/video manipulation and statistics and crypt. The current total
lines of Django is around 12200.
&lt;/p&gt;

&lt;p&gt;
Regarding front end, we use abut 20 OSS libraries to build the
functional GUI such as jQuery, cropper.js, smartcrop.js, Vue, Bootstrap
and so on. The current total lines of JavaScript codes we developed is
around 13000.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e4b2ca" class="outline-4"&gt;
&lt;h4 id="org6e4b2ca"&gt;OS&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6e4b2ca"&gt;
&lt;p&gt;
Ubuntu Server
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcab8702" class="outline-4"&gt;
&lt;h4 id="orgcab8702"&gt;Programming Language&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgcab8702"&gt;
&lt;p&gt;
Python, JavaScript, HTML5, CSS3, JSX, Bash
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0dfe5bd" class="outline-4"&gt;
&lt;h4 id="org0dfe5bd"&gt;Server Side Technologies&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0dfe5bd"&gt;
&lt;p&gt;
Django, MySQL, HTTP2, Web API, video generation engine, image processing,
multi core processing, load distribution
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org92acb9d" class="outline-4"&gt;
&lt;h4 id="org92acb9d"&gt;Front End&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org92acb9d"&gt;
&lt;p&gt;
jQuery, jQuery UI, Vue.js, video.js, cropper.js, smartcrop.js, Bootstrap and much more
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8d5b681" class="outline-4"&gt;
&lt;h4 id="org8d5b681"&gt;Regression Test&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8d5b681"&gt;
&lt;p&gt;
Jenkins, Django UnitTest, Selenium
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf72d417" class="outline-2"&gt;
&lt;h2 id="orgf72d417"&gt;Sequence of video generation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf72d417"&gt;
&lt;p&gt;
&lt;img src="https://cocktailmake.github.io/images/big-picture-of-richka/video-generation-sequence.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
RICHKA is behind a load balancer to distribute lots of coming HTTP
requests to multiple web servers. And to enable simultaneous video
generation at a time, the video generation requests are also
distributed to multiple video servers. The user data such as
images/videos users upload and video template files used by video
engine are stored on an external network storage. They are retrieved
from both web servers and video servers.
&lt;/p&gt;

&lt;p&gt;
The summary sequence of video generation is,
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Users click a button to generate videos and the requests reach one of web servers via the load balancer.&lt;/li&gt;
&lt;li&gt;The web server retrieves the user data such as selected video template and font families and color scheme and BGM and make HTTP requests and send to one of video servers.&lt;/li&gt;
&lt;li&gt;The web server receives the generation progress in realtime and store into the database to show the progress on GUI.&lt;/li&gt;
&lt;li&gt;When the generations have been done, the web server downloads the generated videos and store into the file storage.&lt;/li&gt;
&lt;li&gt;The web server sends the generated videos to web browsers and video player loads them and users can see on GUI.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Infra</category><category>RICHKA</category><guid>https://cocktailmake.github.io/posts/big-picture-of-richka/</guid><pubDate>Tue, 05 May 2020 08:02:40 GMT</pubDate></item></channel></rss>