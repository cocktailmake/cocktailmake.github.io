#+BEGIN_COMMENT
.. title: Narration Recording Developer Document
.. slug: narration-recording-developer-document
.. date: 2020-08-31 03:43:33 UTC+09:00
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text
.. author: Duc To

#+END_COMMENT

* OS

- Use only Linux distribution

We should use only Linux because the production and staging servers are same situation.
And there are many cases to work on the servers with SSH.
Therefore we need to be accustomed to use vi/emacs and general Linux commands for debugging besides Python.

On Emacs, I recommend to use *tramp-mode* because you can remotely edit files of server sides
via SSH with using your local setting and plugins you installed into your local PC. There is no degrade of performance.

* Web Server

- OS: Ubuntu 20.04 LTS
- Python: v3.8
- Django: v2.2.12

* Libraries / commands

- ffmpeg
- imagemagick-6.q16
- libjpeg-dev
- zlib1g-dev

* Google Text-To-Speech API

1. Put the JSON credential file : /var/www/recording_gcp_key.json (Please don't add to Git repository.)
2. Add a environment variable
~export GOOGLE_APPLICATION_CREDENTIALS=/var/www/recording_gcp_key.json~

* Boto3 Amazon Web Services (AWS) SDK for Python (video server only)

Put the AWS configuration and credential files in /var/www/.aws/ (Please don't add to Git repository.)

* Procedure for setting up the development environment

1. Prepare a virtual environment of Ubuntu 20.04 LTS.
2. Check the Python version. If it is 3.8 or more, it is OK. ~$ python3 --version~
3. Install Django v2.2.12 ~$ sudo pip3 install django==v2.2.12~
4. Clone narration product git.
5. Change directory ~cd recording~ and install dependent libraries. ~$ sudo pip3 install -r requirements.txt~
6. To be able to connect to the cloud database and AWS S3, the configuration file received from the member must be placed in "/var/www/.recording.netrc". ~$ cat > /var/www/.recording.netrc~
7. Preparation is complete. Let's actually launch the server. python3 ./manage.py runserver

* Coding Guidelines for Python

- Make sure to use Python v3.6
Python v3.6 is a stable version and also included as default packageon Ubuntu 20.04 LTS.

- Set your editor to use only UTF-8
- Use only LF (0x0A) for a new line
- 4 space characters for indent
[200~Emacs users should include into your .emacs.
~(setq-default tab-width 4 indent-tabs-mode nil)~
- Remove needless whitespace characters.
I recommend to put into your .emacs.

#+BEGIN_SRC sh
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(global-whitespace-mode 1)
#+END_SRC

** Comments

If you implement complicated algorithms or procedures which are difficult for others to understand, please make sure to put explanations as comment to make other members easy to understand.

** Logging

Please use a Python package 'logging'. The output will be serialized into a file descriptor for errors. Therefore the output is serialized into Apache log files and doesn't cause internal server errors.

#+BEGIN_SRC perl
import logging
logging.basicConfig(level=logging.DEBUG) # set logging level
logging.debug("Detected fatal errors!")  # log out as debug level
#+END_SRC

** requirements.txt

When you need new Python packages, please add to requirements.txt.

#+BEGIN_SRC sh
recording/ requirements.txt
#+END_SRC

How to install dependent packages using requirements.txt is below:
~$ sudo pip3 install -r requirements.txt~

* [Coding Guidelines for Web]

- *HTML* : 2 space characters for an indent
- *Javascript* : 4 space characters for an indent
- *CSS* : 4 space characters for an indent

Emacs users should use web-mode and include into your .emacs.

#+BEGIN_SRC sh
(setq web-mode-markup-indent-offset 2)
(setq web-mode-code-indent-offset 4)
(setq web-mode-css-indent-offset 4)
#+END_SRC

* [Git habits]

Please read a good article of Git Workflow [[https://nvie.com/posts/a-successful-git-branching-model/]]

** Branches
When you develop new features or fix bugs and the total lines will be relatively larger compared with prior ones you developed, then you should create new branches and merge after finishing the developments as general Git culture.

** Commit logs

We apply a 3rd party knowledge for the format of commit logs.
[[https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit]]

Please follow the tiny rule in the article above.

#+BEGIN_SRC sh
<type>(<scope>): <subject>
#+END_SRC

Type : Must be one of the following:

#+BEGIN_SRC sh
feat: A new feature
fix: A bug fix
docs: Documentation only changes
style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
refactor: A code change that neither fixes a bug nor adds a feature
perf: A code change that improves performance
test: Adding missing or correcting existing tests
chore: Changes to the build process or auxiliary tools and libraries such as documentation generation
#+END_SRC

For examples, our commit logs would be below.

#+BEGIN_SRC sh
fix(gui): Fixed file uploading. Refs #REC-XXX
fix(video): Make ffmpeg video generation more stable. Refs #REC-XXX
test(django): Added new tests for admin contract page. Refs #REC-XXX
feat(gui) : Added Narration script function. Refs #REC-XXX 
#+END_SRC

** Utilize special keywords in commit logs

When you commit, please make sure to fill understandable commit logs and use special keywords such as Refs #TICKET_NUMBER to make the references with the corresponding tickets on Backlog. Therefore before committing, please create tickets on Backlog at first and make the references with the commit logs.

** Rules for merging

When merging, be sure to add "--no-ff".
example: ~git merge --no-ff feature/REC-00~

** Modification of DB models

When you modify the models of Django with your tasks, please do that on stage branch at first. We sometimes encountered DB migration issue on stage branch and it also caused runtime issue on our individual working branches. To prevent from happening the same issue, we need a working flow to modify DB models.

- Step 1 : If you need to modify models of Django, checkout stage branch at first
- Step 2 : Modify the models and execute migration against staging DB
- Step 3 : Merge stage branch into your working branches

** Git on emacs

The built-in vc of emacs is enough to handle Git, but *magit* is also worth trying.

* [Testing]

When you have developed new features or fixed bugs, please create the corresponding unittest or join tests.

* [Deploy]

*The role of the web server*

Send web contents such as HTML/CSS/JS.
Store video and narration script uploaded by users.
Delegate a heavy workload of a video generation to video servers.
Download the generated videos and serve to users' web browsers.

*The role of the video server*

Generate video with user uploaded video and recorded audio.
Notify the web server of the progress of the video generation and the URL of the generated video.

*production server*

** Production deployment procedure

- Create a new release branches based on latest stage branch for both recording and video repositories (even thought there may not has any chances since last release for one repository)
- Deploy release branches to production recording and production recording ffmpeg servers
- Test to make sure that all fundemental features work properly
- Apply hotfix commits to release branches as there are bugs during above test steps
- Create tags for both repositores release branches after release review successfully passed.
- New version release announcement

*staging server*

The main role of this server is to validate new features and check the stability.

** Specific situations we need to take care

Sometimes we encounter errors which happen only on servers.
Therefore we need to be familiar with analyzing the Apache logs and network protocols such as HTTP.

** Development procedure

1. Create new branch and start an assigned ticket. For example$ git checkout -b feature/REC-70
2. When you're done, push the branch.
3. Deploy to a staging server (2 - 20).
4. Ask the reviewer for confirmation.
5. If there is no problem, merge to stage branch.

** How to deploy

*When asking a reviewer for confirmation*
1. SSH access with VPN connection.
2. Go to the server to deploy. example:~$ cd /var/recording/2~
　There are 2 to 10 staging servers for confirmation.
3. Check if the directory is in use. ~$ git status~
　If it is the stage branch, you can use it. If else, please look for available directory.
　If no server is available, please ask other member.
4. ~$ git pull~ and ~$ git checkout feature/REC-○~ ※*Please do not ~$ sudo git pull.~*
5. Restart Apache. ~$ sudo service apache2 restart~ or ~$ sudo /etc/init.d/apache2 restart~

That's it!
Now, let's access the staging server and check.

*When the ticket is completed and you will merge into the stage branch*
1. Update the stage to the latest state. ~git pull origin stage~
2. Merge ticket branch to stage. ~git merge --no-ff feature/REC-○~
3. push the stage. ~git push origin stage~
4. SSH access with VPN connection.
5. Go to the server to deploy. ~$ cd /var/recording/1~
6. ~$ git pull~ ※*Please do not ~$ sudo git pull~*.
7. Restart Apache. ~$ sudo service apache2 restart~ or ~$ sudo /etc/init.d/apache2 restart~

* [References]

- Python 3.8.2 API document

[[https://docs.python.org/3.8/]]

- Django
[[https://docs.djangoproject.com/en/2.2/]]

At least, please read the tutorial and obtain the fundamental by practices in your local PC.i

*We use Django v2.2.12 on v1 service.*

~$ sudo pip3 install django==2.2.12~

- WebRTC for get audio input

[[https://webrtc.org/]]

We're using the standard promise based getUserMedia()

[[https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia]]

- Videojs-markers

[[https://github.com/spchuang/videojs-markers]]

API document : [[http://sampingchuang.com/videojs-markers]]

- FFMPEG for video generation

[[http://ffmpeg.org/ffmpeg-all.html]]

ffmpeg is used to generate videos. It should be built with hardware accelerator options.

Some techniques are used to make the performance faster.

- Tools for Backlog

[[https://backlog.com/ja/developer/showcase/]]

- Profiling Django

Install some tools

#+BEGIN_SRC sh
$ sudo pip3 install django-extensions  # profiler extension of Django
$ sudo pip3 install gprof2dot          # converts profiling output to a dot graph
$ sudo apt install graphviz            # convert a dot graph to a PNG file
#+END_SRC

Setup settings.py

#+BEGIN_SRC sh
INSTALLED_APP = (...
   'django_extensions',
)
#+END_SRC

Launch Django with the profiler and serialize the analyzed data into the specified directory.

#+BEGIN_SRC sh
$ python manage.py runprofileserver --use-cprofile --prof-path=/tmp/django-profile
#+END_SRC

Visualize one of the profiler results.

#+BEGIN_SRC sh
$ gprof2dot -f pstats /tmp/django-profile/get_paged_template_list.009201ms.1556530628.prof | dot -Tpng -o output.png
#+END_SRC

References
[[https://django-extensions.readthedocs.io/en/latest/runprofileserver.html]]
[[https://github.com/jrfonseca/gprof2dot]]

* [Utility Scripts]

To find available virtual host on staging web servers.

#+BEGIN_SRC sh
    BACKLOG_APIKEY='YOUR_API_KEY'
    vhost-branch-status() {
        server=$1
        root_dir=$2
        for dname in `ssh $server "ls $root_dir"|sort -n`;do
            echo "$root_dir/$dname"
            branch=$(ssh $server "cd $root_dir/$dname; git branch | sed -n '/\* /s///p'")
            ticket_id=$(echo $branch | awk -F '/' '{print $2}')
            status=$(curl -s https://enk.backlog.jp/api/v2/issues/${ticket_id}?apiKey=$BACKLOG_APIKEY | jq '.status.name')
            if [ "$status" = "null" ];then status="-"; fi
            echo "$branch : $status"
            echo
        done
    }
    alias richka-vhost-status="vhost-branch-status richka-stage-web1 /var/v2"
    alias rec-vhost-status="vhost-branch-status recording-stage-web /var/recording"
#+END_SRC
